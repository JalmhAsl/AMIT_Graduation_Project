#define		F_CPU		16000000UL

#include	"Std_Types.h"
#include	"Bit_Math.h"

#include	"DIO_interface.h"
#include	<util/delay.h>

#include	"GLCD_private.h"
#include	"GLCD_interface.h"


/*------------------------- Font Bytes Array Definition -----------------------------*/


static u8 font[][6] =			/* Define char fonts array in column by row in flash memory */
{
	 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 00
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 01
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 02
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 03
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 04
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 05
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 06
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 07
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 08
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 09
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0A
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0B
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0C
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0D
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0E
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 0F
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 10
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 11
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 12
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 13
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 14
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 15
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 16
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 17
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 18
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 19
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1A
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1B
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1C
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1D
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1E
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 1F
	 ,{0x00, 0x00, 0x00, 0x00, 0x00, 0x00} // 20 (Space)
	 ,{0x00, 0x00, 0x5f, 0x00, 0x00, 0x00} // 21 !
	 ,{0x00, 0x07, 0x00, 0x07, 0x00, 0x00} // 22 "
	 ,{0x14, 0x7f, 0x14, 0x7f, 0x14, 0x00} // 23 #
	 ,{0x24, 0x2a, 0x7f, 0x2a, 0x12, 0x00} // 24 $
	 ,{0x23, 0x13, 0x08, 0x64, 0x62, 0x00} // 25 %
	 ,{0x36, 0x49, 0x55, 0x22, 0x50, 0x00} // 26 &
	 ,{0x00, 0x05, 0x03, 0x00, 0x00, 0x00} // 27 '
	 ,{0x00, 0x1c, 0x22, 0x41, 0x00, 0x00} // 28 (
	 ,{0x00, 0x41, 0x22, 0x1c, 0x00, 0x00} // 29 )
	 ,{0x14, 0x08, 0x3e, 0x08, 0x14, 0x00} // 2a *
	 ,{0x08, 0x08, 0x3e, 0x08, 0x08, 0x00} // 2b +
	 ,{0x00, 0x50, 0x30, 0x00, 0x00, 0x00} // 2c ,
	 ,{0x08, 0x08, 0x08, 0x08, 0x08, 0x00} // 2d -
	 ,{0x00, 0x60, 0x60, 0x00, 0x00, 0x00} // 2e .
	 ,{0x20, 0x10, 0x08, 0x04, 0x02, 0x00} // 2f /
	 ,{0x3e, 0x51, 0x49, 0x45, 0x3e, 0x00} // 30 0
	 ,{0x00, 0x42, 0x7f, 0x40, 0x00, 0x00} // 31 1
	 ,{0x42, 0x61, 0x51, 0x49, 0x46, 0x00} // 32 2
	 ,{0x21, 0x41, 0x45, 0x4b, 0x31, 0x00} // 33 3
	 ,{0x18, 0x14, 0x12, 0x7f, 0x10, 0x00} // 34 4
	 ,{0x27, 0x45, 0x45, 0x45, 0x39, 0x00} // 35 5
	 ,{0x3c, 0x4a, 0x49, 0x49, 0x30, 0x00} // 36 6
	 ,{0x01, 0x71, 0x09, 0x05, 0x03, 0x00} // 37 7
	 ,{0x36, 0x49, 0x49, 0x49, 0x36, 0x00} // 38 8
	 ,{0x06, 0x49, 0x49, 0x29, 0x1e, 0x00} // 39 9
	 ,{0x00, 0x36, 0x36, 0x00, 0x00, 0x00} // 3a :
	 ,{0x00, 0x56, 0x36, 0x00, 0x00, 0x00} // 3b ;
	 ,{0x08, 0x14, 0x22, 0x41, 0x00, 0x00} // 3c <
	 ,{0x14, 0x14, 0x14, 0x14, 0x14, 0x00} // 3d =
	 ,{0x00, 0x41, 0x22, 0x14, 0x08, 0x00} // 3e >
	 ,{0x02, 0x01, 0x51, 0x09, 0x06, 0x00} // 3f ?
	 ,{0x32, 0x49, 0x79, 0x41, 0x3e, 0x00} // 40 @
	 ,{0x7e, 0x11, 0x11, 0x11, 0x7e, 0x00} // 41 A
	 ,{0x7f, 0x49, 0x49, 0x49, 0x36, 0x00} // 42 B
	 ,{0x3e, 0x41, 0x41, 0x41, 0x22, 0x00} // 43 C
	 ,{0x7f, 0x41, 0x41, 0x22, 0x1c, 0x00} // 44 D
	 ,{0x7f, 0x49, 0x49, 0x49, 0x41, 0x00} // 45 E
	 ,{0x7f, 0x09, 0x09, 0x09, 0x01, 0x00} // 46 F
	 ,{0x3e, 0x41, 0x49, 0x49, 0x7a, 0x00} // 47 G
	 ,{0x7f, 0x08, 0x08, 0x08, 0x7f, 0x00} // 48 H
	 ,{0x00, 0x41, 0x7f, 0x41, 0x00, 0x00} // 49 I
	 ,{0x20, 0x40, 0x41, 0x3f, 0x01, 0x00} // 4a J
	 ,{0x7f, 0x08, 0x14, 0x22, 0x41, 0x00} // 4b K
	 ,{0x7f, 0x40, 0x40, 0x40, 0x40, 0x00} // 4c L
	 ,{0x7f, 0x02, 0x0c, 0x02, 0x7f, 0x00} // 4d M
	 ,{0x7f, 0x04, 0x08, 0x10, 0x7f, 0x00} // 4e N
	 ,{0x3e, 0x41, 0x41, 0x41, 0x3e, 0x00} // 4f O
	 ,{0x7f, 0x09, 0x09, 0x09, 0x06, 0x00} // 50 P
	 ,{0x3e, 0x41, 0x51, 0x21, 0x5e, 0x00} // 51 Q
	 ,{0x7f, 0x09, 0x19, 0x29, 0x46, 0x00} // 52 R
	 ,{0x46, 0x49, 0x49, 0x49, 0x31, 0x00} // 53 S
	 ,{0x01, 0x01, 0x7f, 0x01, 0x01, 0x00} // 54 T
	 ,{0x3f, 0x40, 0x40, 0x40, 0x3f, 0x00} // 55 U
	 ,{0x1f, 0x20, 0x40, 0x20, 0x1f, 0x00} // 56 V
	 ,{0x3f, 0x40, 0x38, 0x40, 0x3f, 0x00} // 57 W
	 ,{0x63, 0x14, 0x08, 0x14, 0x63, 0x00} // 58 X
	 ,{0x07, 0x08, 0x70, 0x08, 0x07, 0x00} // 59 Y
	 ,{0x61, 0x51, 0x49, 0x45, 0x43, 0x00} // 5a Z
	 ,{0x00, 0x7f, 0x41, 0x41, 0x00, 0x00} // 5b [
	 ,{0x02, 0x04, 0x08, 0x10, 0x20, 0x00} // 5c Ñ
	 ,{0x00, 0x41, 0x41, 0x7f, 0x00, 0x00} // 5d ]
	 ,{0x04, 0x02, 0x01, 0x02, 0x04, 0x00} // 5e ^
	 ,{0x40, 0x40, 0x40, 0x40, 0x40, 0x00} // 5f _
	 ,{0x00, 0x01, 0x02, 0x04, 0x00, 0x00} // 60 `
	 ,{0x20, 0x54, 0x54, 0x54, 0x78, 0x00} // 61 a
	 ,{0x7f, 0x48, 0x44, 0x44, 0x38, 0x00} // 62 b
	 ,{0x38, 0x44, 0x44, 0x44, 0x20, 0x00} // 63 c
	 ,{0x38, 0x44, 0x44, 0x48, 0x7f, 0x00} // 64 d
	 ,{0x38, 0x54, 0x54, 0x54, 0x18, 0x00} // 65 e
	 ,{0x08, 0x7e, 0x09, 0x01, 0x02, 0x00} // 66 f
	 ,{0x0c, 0x52, 0x52, 0x52, 0x3e, 0x00} // 67 g
	 ,{0x7f, 0x08, 0x04, 0x04, 0x78, 0x00} // 68 h
	 ,{0x00, 0x44, 0x7d, 0x40, 0x00, 0x00} // 69 i
	 ,{0x20, 0x40, 0x44, 0x3d, 0x00, 0x00} // 6a j
	 ,{0x7f, 0x10, 0x28, 0x44, 0x00, 0x00} // 6b k
	 ,{0x00, 0x41, 0x7f, 0x40, 0x00, 0x00} // 6c l
	 ,{0x7c, 0x04, 0x18, 0x04, 0x78, 0x00} // 6d m
	 ,{0x7c, 0x08, 0x04, 0x04, 0x78, 0x00} // 6e n
	 ,{0x38, 0x44, 0x44, 0x44, 0x38, 0x00} // 6f o
	 ,{0x7c, 0x14, 0x14, 0x14, 0x08, 0x00} // 70 p
	 ,{0x08, 0x14, 0x14, 0x18, 0x7c, 0x00} // 71 q
	 ,{0x7c, 0x08, 0x04, 0x04, 0x08, 0x00} // 72 r
	 ,{0x48, 0x54, 0x54, 0x54, 0x20, 0x00} // 73 s
	 ,{0x04, 0x3f, 0x44, 0x40, 0x20, 0x00} // 74 t
	 ,{0x3c, 0x40, 0x40, 0x20, 0x7c, 0x00} // 75 u
	 ,{0x1c, 0x20, 0x40, 0x20, 0x1c, 0x00} // 76 v
	 ,{0x3c, 0x40, 0x30, 0x40, 0x3c, 0x00} // 77 w
	 ,{0x44, 0x28, 0x10, 0x28, 0x44, 0x00} // 78 x
	 ,{0x0c, 0x50, 0x50, 0x50, 0x3c, 0x00} // 79 y
	 ,{0x44, 0x64, 0x54, 0x4c, 0x44, 0x00} // 7a z
	 ,{0x00, 0x08, 0x36, 0x41, 0x00, 0x00} // 7b {
	 ,{0x00, 0x00, 0x7f, 0x00, 0x00, 0x00} // 7c |
	 ,{0x00, 0x41, 0x36, 0x08, 0x00, 0x00} // 7d }
	 ,{0x10, 0x08, 0x08, 0x10, 0x08, 0x00} // 7e ->
	 ,{0x78, 0x46, 0x41, 0x46, 0x78, 0x00} // 7f <-
};


/*----------------------- Global Variables -------------------------*/

/*	Global Variable to keep track of the X position of the cursor	*/
static		u8		X_coord = 0;

/*	Global Variable to keep track of the Y position of the cursor	*/
static		u8		Y_coord = 0;

/*	Global Variable to keep track of the current selected screen	*/
static		u8		Curr_Screen = No_Screen;


/*----------------------- GLCD Functions ---------------------------*/

void	GLCD_voidInit(void)
{
	/*	Set ports direction										*/
	DIO_voidSetPortDirection(GLCD_CONTROL_PORT, OUTPUT);
	DIO_voidSetPortDirection(GLCD_DATA_PORT, OUTPUT);

	/*	Initialize both halves of the screen and sets RESET Pin*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_CS1, LOW);
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_CS2, LOW);
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_RST, HIGH);

	/*	Turns display OFF		*/
	GLCD_voidSendCMD(0x3E); // = 0011 1110 where D0 controls display
	_delay_ms(2);
	/*	Sets Y position at top-left corner	*/
	GLCD_voidSendCMD(0x40);
	_delay_ms(2);
	/*	Sets X position at Page 0	*/
	GLCD_voidSendCMD(0xB8);	// = 1101 1000 where D0,D1 and D2 are 0 (Pixel row 0)
	_delay_ms(2);
	/*	Select Start Line			*/
	GLCD_voidSelectStartLine(0);
	_delay_ms(2);
	/*	Turns display ON		*/
	GLCD_voidSendCMD(0x3F);
	_delay_ms(2);
	/*	Clear All Screen		*/
	GLCD_voidClearAll();
	_delay_ms(2);
}


void	GLCD_voidSendCMD(u8 CMD)
{
	/*		RS low for instruction register			*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_RS, LOW);
	/*		RW low for writing commands				*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_RW, LOW);
	
	/*		Send command to DATA port				*/
	DIO_voidSetPortValue(GLCD_DATA_PORT, CMD);

	/*		EN pin must transit from HIGH to LOW	*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_EN, HIGH);
	_delay_us(5);
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_EN, LOW);
	_delay_us(5);

}


void	GLCD_voidSendData(u8 DATA)
{
	/*		RS high for instruction register		*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_RS, HIGH);
	/*		RW low for writing commands				*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_RW, LOW);
	
	/*		Send command to DATA port				*/
	DIO_voidSetPortValue(GLCD_DATA_PORT, DATA);
	
	/*		Update value of Y coordinate each time Data is sent		*/
	Y_coord++;

	/*		EN pin must transit from HIGH to LOW	*/
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_EN, HIGH);
	_delay_us(5);
	DIO_voidSetPinValue(GLCD_CONTROL_PORT, GLCD_EN, LOW);
	_delay_us(5);
}


void	GLCD_voidWriteStr(u8 str[])
{
	/*	Outer for loops through characters of string input	*/
	for (u8 i = 0; str[i] != '\0'; i++)
	{
		/*	Checks if there is enough place to display a character at the end of RIGHT_SCREEN	*/
		if (Y_coord > 122)
			{
				if (X_coord < 8)
					GLCD_voidSetXY(X_coord + 1, 0);
				
				else
					GLCD_voidSetXY(0, 0);
			}
			
			
		/*	Inner for loops through each column to turn ON/OFF pixels	*/
		for (u8 j = 0; j < 6; j++)
		{	
			/*	Check if the last column has been reached	*/
			if (Y_coord < 64)
				GLCD_voidSendData(font[str[i]][j]);
				
			/*	In case it reached the last column, switch to the RIGHT_SCREEN	*/
			else if (Y_coord >= 64)
			{
				GLCD_voidSetXY(X_coord, Y_coord);
				GLCD_voidSendData(font[str[i]][j]);
			}
		}
	}
}


void	GLCD_voidWriteInt(u16 num)
{
	u8 l = 0;
	if (num >= 10000)
		l = 5;
	else if (num >= 1000)
		l = 4;
	else if (num >= 100)
		l = 3;
	else if (num >= 10)
		l = 2;
	else if (num >= 0)
		l = 1;
		
	switch (l)
	{
		case 5: for(u8 i = 0; i < 6; i++) 
				{
					GLCD_voidSetXY(X_coord, Y_coord);
					GLCD_voidSendData(font[((num/10000)%10)+48][i]);
				}
		case 4:	for(u8 i = 0; i < 6; i++)
				{
					GLCD_voidSetXY(X_coord, Y_coord);
					GLCD_voidSendData(font[((num/1000)%10)+48][i]);
				}
		case 3:	for(u8 i = 0; i < 6; i++)
				{
					GLCD_voidSetXY(X_coord, Y_coord);
					GLCD_voidSendData(font[((num/100)%10)+48][i]);
				}
		case 2:	for(u8 i = 0; i < 6; i++)
				{
					GLCD_voidSetXY(X_coord, Y_coord);
					GLCD_voidSendData(font[((num/10)%10)+48][i]);
				}
		case 1:	for(u8 i = 0; i < 6; i++)
				{
					GLCD_voidSetXY(X_coord, Y_coord);
					GLCD_voidSendData(font[((num/1)%10)+48][i]);
				}
				break;
	}
}


void	GLCD_voidSelectStartLine(u8 Line)
{
	if (Line >= 0 && Line < 64)
	{
		GLCD_voidSendCMD(0xC0 + 64 - Line);
	}
}


void	GLCD_voidSelectPage(u8 row)
{
	if (row >= 0 && row < 8)
	{
		GLCD_voidSendCMD((0xB8) + row);
		X_coord = row;
	}
}


/*		Values from 0 to 63		*/
void	GLCD_voidSelectColumn(u8 col)
{
	if (col >= 0 && col < 64)
	{
		GLCD_voidSendCMD((0x40) + col);
		Y_coord = col;
	}
	else if (col >= 64 && col < 128)
	{
		GLCD_voidSendCMD((0x40) + col - 64);
		Y_coord = col;
	}
}


void	GLCD_voidSelectScreen(u8 screen)
{
	if (screen == Left_Screen)
	{
		DIO_voidSetPinValue(PORTA, GLCD_CS1, LOW);
		DIO_voidSetPinValue(PORTA, GLCD_CS2, HIGH);
		Curr_Screen = Left_Screen;
	}
	else if (screen == Right_Screen)
	{
		DIO_voidSetPinValue(PORTA, GLCD_CS1, HIGH);
		DIO_voidSetPinValue(PORTA, GLCD_CS2, LOW);
		Curr_Screen = Right_Screen;
	}
	else if (screen == Both_Screens)
	{
		DIO_voidSetPinValue(PORTA, GLCD_CS1, LOW);
		DIO_voidSetPinValue(PORTA, GLCD_CS2, LOW);
		Curr_Screen = Both_Screens;
	}
}


void	GLCD_voidSetXY(u8 x, u8 y)	/*	From [0,0] (=top-left corner) to [7,127] (=bottom-right corner)	*/
{
	
	/*	Defines which screen is turned ON. Also defines Y position of Cursor	*/
	if (y >= 0 && y < 64)
	{
		GLCD_voidSelectScreen(Left_Screen);
		GLCD_voidSelectColumn(y);
	}
	
	else if (y >= 64 && y < 128)
	{
		GLCD_voidSelectScreen(Right_Screen);
		GLCD_voidSelectColumn(y);
	}
	
	/*	Defines X Position after screen changed		*/
	if (x >= 0 && x < 8)
	{
		GLCD_voidSelectPage(x);
	}
	
}


void	GLCD_voidClearPage(u8 x)
{
	/*	Select left and right screens */
	GLCD_voidSelectScreen(Both_Screens);
	
	/*	Select Page					*/
	GLCD_voidSelectPage(x);
	
	/*	Clears every pixel in page	*/
	for(u8 j = 0; j < 64; j++)
	{
		GLCD_voidSendData(0); // Turns OFF each pixel in each column of each page
		// Automatically increments Y-Axis
	}
	
}


void	GLCD_voidClearAll(void)
{
	/* Select left and right screens */
	GLCD_voidSelectScreen(Both_Screens);
	Curr_Screen = Both_Screens;
	
	for(u8 i = 0; i < 8; i++)
	{
		GLCD_voidSendCMD((0xB8) + i); // Increment each page
		
		for(u8 j = 0; j < 64; j++)
		{
			GLCD_voidSendData(0); // Turns OFF each pixel in each column of each page
								  // Automatically increments Y-Axis
		}
	}
	GLCD_voidSendCMD(0x40);		/* Resets Y address to 0 */
	Y_coord = 0;
	GLCD_voidSendCMD(0xB8);		/* Resets X address to Page 0 */
	X_coord = 0;
}